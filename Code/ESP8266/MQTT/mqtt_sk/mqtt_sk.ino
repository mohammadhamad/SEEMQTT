

#include <ESP8266WiFi.h>
#include <PubSubClient.h>

#include <Crypto.h>


//for AES block cipher and rsa  
#include <bearssl_block.h> 
#include <bearssl_rsa.h> 
#include <bearssl_hash.h> 
#include <base64.hpp>
/* Debug the code */
#define DBUG

/* print the time measurment */ 
#define TIME_DEBUG

/* by enable   that we enforrce the connection to be closed after  each transmission */
//#define RECON

#define CRY_DEBUG
#define CRY_DEBUG_AES
//#define CRY_DEBUG_RSA_SIGN
#define BLOCK_SIZE 16


/*size of the message */
#define Size_Byte 32

//#define OSLOENABLE
 uint8_t * mymsg; 

 /* symetric key to encrypt the date*/
 uint8_t key[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

 /* Initial Value for encryption */  
//uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/*
 * Key Store Public key 
 */
 unsigned char KS_RSA_N[] = {
    0x00,0xd7,0xbc,0xa7,0xf9,0xad,0x17,0xb4,0x61,0x04,0x77,0x5c,0xd5,0x41,0x26,
    0x15,0xed,0xc1,0x03,0x4c,0x82,0x99,0xae,0x4b,0x12,0xce,0x4b,0x60,0xa6,0xb8,
    0xea,0x9b,0xd1,0xb6,0x00,0x8c,0x2e,0x2c,0xe4,0x39,0x9d,0xc5,0x6f,0x4c,0x6c,
    0x0f,0x0e,0x41,0x53,0x89,0x24,0x50,0x0b,0xad,0xd4,0x1e,0x83,0xf6,0xb0,0xb8,
    0xbd,0xf1,0x94,0x83,0xd9,0x4e,0x24,0xe0,0xde,0xf6,0xf0,0x44,0x8a,0xf7,0xfe,
    0x5d,0x80,0x71,0xe4,0xc0,0x75,0xf3,0x09,0x1e,0x96,0xdd,0x20,0x9f,0x35,0x99,
    0xc5,0x10,0x7d,0xcb,0x6c,0xb5,0x85,0x24,0x6e,0x90,0xba,0xc7,0xc8,0x67,0x81,
    0x43,0x46,0xba,0x0d,0x98,0xe8,0xe1,0x2d,0x3b,0x22,0x7b,0x8f,0x10,0x34,0x6f,
    0xb0,0xe3,0x22,0xe6,0x7b,0xe6,0x81,0xc9,0x83
};
unsigned char KS_RSA_E[] = {
  0x01, 0x00, 0x01
};
static const br_rsa_public_key KS_RSA_PK = {
  KS_RSA_N, sizeof KS_RSA_N,
  KS_RSA_E, sizeof KS_RSA_E
};

/*
 * IOT RSA public and prrivate keys generated by openssl 
 */
 unsigned char RSA_N[] = {
    0x00,0xba,0xb8,0x44,0xe5,0xf9,0xbb,0x95,0x8e,0xad,0xc2,0xb9,0x67,0xca,0x8f,
    0xaf,0x4e,0x1c,0xd1,0x10,0xa0,0x5a,0x8c,0xf1,0x92,0xe1,0x10,0x07,0x43,0x3a,
    0xf5,0x3a,0xdf,0xad,0x7a,0xac,0x94,0x9e,0xeb,0x97,0xc4,0xb8,0x0f,0x5c,0xd6,
    0x03,0xe9,0x50,0xfb,0xf4,0x82,0x89,0xbc,0xf6,0x63,0xbd,0x38,0xda,0xf2,0x14,
    0x51,0x1d,0x99,0x7c,0x41,0xbb,0xd3,0x61,0x11,0x8e,0x47,0x56,0x0c,0x80,0x47,
    0x01,0x3c,0xa3,0xab,0x55,0xce,0x68,0xc0,0x4f,0x7c,0xee,0x7b,0x21,0xd0,0xa6,
    0x6d,0x1a,0xa9,0x37,0x93,0x5d,0xbe,0xed,0x64,0x92,0xce,0x35,0x5e,0x1e,0x9f,
    0x79,0x43,0xb8,0xd9,0x59,0xb5,0xd3,0x94,0x31,0xae,0x82,0xe2,0xbf,0x0e,0x0f,
    0x1a,0x45,0x0e,0xda,0x82,0xff,0x08,0x73,0x2f
};
unsigned char RSA_E[] = {
  0x01, 0x00, 0x01
};
  unsigned char RSA_P[] = {
  0x00,0xeb,0xc4,0xcf,0x5a,0xa1,0x72,0xa9,0x50,
  0x6c,0x3e,0xad,0x7c,0xb8,0xab,0x62,0x40,0x9b,
  0x8f,0xb7,0x6a,0x70,0xb1,0x96,0x4d,0x4e,0x7f,
  0x7a,0xa7,0x20,0x4c,0x99,0x55,0x1b,0xa9,0x8f,0x62,0x0e,0x7d,0x0a,0xae,
  0xf2,0x97,0xcf,0xb7,0x34,0xfc,0xf6,0x75,0x11,0x52,0x2d,0xfd,0x99,0x97,0xf4,0x80,0x8b,0x4a,0xab,0x20,0x75,0xa5,0xcc,0x59 
};
 unsigned char RSA_Q[] = {
    0x00,0xca,0xbd,0xfc,0xf9,0x58,0xe9,0xd7,0xe2,0x02,0x10,0xc2,0xc5,0x89,0x8e,
    0x32,0xde,0x96,0x90,0xf8,0xcc,0x5b,0x96,0x52,0x1b,0x8b,0x45,0xda,0x36,0xcc,
    0xae,0x93,0x21,0xcd,0x61,0x7b,0x84,0x65,0x5e,0x43,0x06,0x05,0x87,0x00,0x1b,
    0x99,0x21,0x99,0x11,0xf7,0xef,0xba,0xfe,0xf7,0x73,0x08,0xb0,0xdb,0x5e,0xa6,
    0x5b,0xa0,0xa0,0x2a,0xc7
};
 unsigned char RSA_DP[] = {0x00,0x96,0xd6,0xd6,0xb6,0xac,0x3e,0x18,0x97,0x0c,0x79,
 0xd9,0x32,0xc7,0x4f,0x56,0xcf,0xf0,0xf6,0xb4,0xa9,0x13,0xaa,0x7a,0x77,0xc1,0x36,
 0x0b,0xf9,0xaa,0xcf,0x76,0xf6,0x1d,0x79,0x90,0xf3,0x72,0x43,0x8b,0xb7,0x3c,0x1b,
 0xe6,0x57,0xd7,0x3d,0xd4,0x4c,0x37,0xa5,0xb5,0x28,0xdf,0xc0,0x79,0x3c,0x58,0x61,
 0x90,0x34,0x77,0x30,0x79,0x19
};
 unsigned char RSA_DQ[] = {
  0x5d,0x3e,0xf0,0x60,0xc6,0x52,0x16,0xe6,0x6d,0xc8,0xc3,
  0xac,0x12,0xce,0x01,0xfb,0x7a,0x08,0x87,0x45,0x86,0x42,
  0x26,0xd5,0x60,0x42,0xea,0x50,0x15,0xe7,0x9c,0xe8,0x09,
  0x0b,0xf2,0xc1,0x3b,0xd6,0x14,0xc1,0x6a,0x3d,0x63,0x01,
  0x4e,0x76,0xb3,0x6e,0x1e,0x38,0x76,0x2a,0xda,0x28,0x60,
  0x30,0xe7,0x54,0x2a,0xf3,0x2d,0x77,0x3c,0xf5
};
 unsigned char RSA_IQ[] = {
  0x00,0xc5,0xd7,0x18,0x69,0x9b,0xb9,0x48,0xa6,0xde,0x5c,0x19,0xc6,0xb0,0xc6,
  0xf3,0x0f,0xb7,0x53,0xdd,0xc1,0x09,0x08,0xf1,0x77,0xce,0xa4,0x63,0xdb,0x63,
  0x7d,0xe5,0x14,0xc2,0x47,0x56,0x8c,0xe8,0x39,0xe9,0xb1,0x10,0x6d,0x76,0x57,
  0xe8,0x9f,0x57,0xf1,0xa8,0x77,0xcb,0xc1,0xee,0x29,0xd3,0x10,0x23,0xf3,0xd9,
  0x44,0x79,0xd9,0xe2,0x78
};

static const br_rsa_public_key RSA_PK = {
  RSA_N, sizeof RSA_N,
  RSA_E, sizeof RSA_E
};

static const br_rsa_private_key RSA_SK = {
  1024,
  RSA_P, sizeof RSA_P,
  RSA_Q, sizeof RSA_Q,
  RSA_DP, sizeof RSA_DP,
  RSA_DQ, sizeof RSA_DQ,
  RSA_IQ, sizeof RSA_IQ
};

static const unsigned char SHA1_OID[] = {
  0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A
};

// Update these with values suitable for your network.
const char* ssid = "mhhap";
const char* password = "mhh1986mhh";
const char* mqtt_server =  "192.168.12.232"; //"mqtt.eclipse.org";
const int mqttPort = 2222; //1883

WiFiClient espClient;
PubSubClient client(espClient);

unsigned long lastMsg = 0;
#define MSG_BUFFER_SIZE  (50)
char msg[MSG_BUFFER_SIZE];
int value = 0; /* counter for the messages*/


/*
 *  function for RSA encryption 
 */
typedef struct {
  const br_prng_class *vtable;
  unsigned char buf[128];
  size_t ptr, len;
} rng_fake_ctx;

 void rng_fake_init(rng_fake_ctx *cc, const void *params, const void *seed, size_t len);
 void rng_fake_generate(rng_fake_ctx *cc, void *dst, size_t len);
 void rng_fake_update(rng_fake_ctx *cc, const void *src, size_t len);

 const br_prng_class rng_fake_vtable = {
  sizeof(rng_fake_ctx),
  (void (*)(const br_prng_class **,
    const void *, const void *, size_t))&rng_fake_init,
  (void (*)(const br_prng_class **,
    void *, size_t))&rng_fake_generate,
  (void (*)(const br_prng_class **,
    const void *, size_t))&rng_fake_update
};

 void rng_fake_init(rng_fake_ctx *cc, const void *params, const void *seed, size_t len)
{
  (void)params;
  if (len > sizeof cc->buf) {
    Serial.print("seed is too large ( bytes)\n");
    Serial.println ((unsigned long)len);
    //exit(EXIT_FAILURE);
  }
  cc->vtable = &rng_fake_vtable;
  memcpy(cc->buf, seed, len);
  cc->ptr = 0;
  cc->len = len;
}

 void rng_fake_generate(rng_fake_ctx *cc, void *dst, size_t len)
{
  if (len > (cc->len - cc->ptr)) {
   // fprintf(stderr, "asking for more data than expected\n");
    exit(EXIT_FAILURE);
  }
  memcpy(dst, cc->buf + cc->ptr, len);
  cc->ptr += len;
}

 void rng_fake_update(rng_fake_ctx *cc, const void *src, size_t len)
{
 
}
int 
check_equals(const char *banner, const void *v1, const void *v2, size_t len)
{
  
  unsigned char *b;

  if (memcmp(v1, v2, len) == 0) {
    return 0;
  }
  else 
  return -1; 
  /*
  Serial.print( "v1: ");
  for (int u = 0, b = ( unsigned char *)v1; u < len; u ++) {
    Serial.print(b[u], HEX);
    Serial.print(" ");
  }
  Serial.println(); 
  Serial.print("v2: ");
  for (int u = 0, b = ( unsigned char *)v2; u < len; u ++) {
     Serial.print(b[u], HEX);
    Serial.print(" ");
  }
  Serial.println(); 
  return 1; 

   */
}

size_t hextobin(unsigned char *dst, const char *src)
{
  size_t num;
  unsigned acc;
  int z;

  num = 0;
  z = 0;
  acc = 0;
  while (*src != 0) {
    int c = *src ++;
    if (c >= '0' && c <= '9') {
      c -= '0';
    } else if (c >= 'A' && c <= 'F') {
      c -= ('A' - 10);
    } else if (c >= 'a' && c <= 'f') {
      c -= ('a' - 10);
    } else {
      continue;
    }
    if (z) {
      *dst ++ = (acc << 4) + c;
      num ++;
    } else {
      acc = c;
    }
    z = !z;
  }
  return num;
}
/*
 * RSA SIGNING
 * signedhash (128)
 */
void rsa_sign( char * msg ,  unsigned char * signedhash,  br_rsa_pkcs1_sign fsign)
{
  #ifdef CRY_DEBUG_RSA_SIGN
  Serial.println("<<<<<<<<<<<<<Start Sign>>>>>>>>>>>>>>>>>>"); 
  #endif
  
  unsigned char hv[20];
  br_sha1_context hc;
  size_t u;

  br_sha1_init(&hc);
  br_sha1_update(&hc, msg, strlen(msg));
  br_sha1_out(&hc, hv);
 
  #ifdef CRY_DEBUG_RSA_SIGN
  Serial.println("Hash Value :"); 
  Print(hv, 20, 0 ); 
  #endif
  unsigned long start = millis(); 
  if (!fsign(SHA1_OID, hv, 20, &RSA_SK, signedhash)) {
    Serial.println("Signature generation failed");
  }
  unsigned long end = millis();
  
  #ifdef TIME_DEBUG
  Serial.print(" Time to sign "); 
  Serial.println(end-start); 
  #endif
  
  #ifdef CRY_DEBUG_RSA_SIGN
  Serial.println(" signature :"); 
  dbgPrint(signedhash, 128, 0); 
  Serial.println("<<<<<<<<<<<<<End Sign>>>>>>>>>>>>>>>>>>"); 
  #endif
  }
  
/*
 * RSA Encryption 
 */
//int  rsa_encrypt(char * plaintext, unsigned char * output, br_rsa_oaep_encrypt menc)
int  rsa_encrypt(unsigned char * plaintext, unsigned char * output, br_rsa_oaep_encrypt menc)
  {
  #ifdef CRY_DEBUG
  Serial.println("<<<<<<<<<<<<<Start RSA Encryption>>>>>>>>>>>>>>>>>>"); 
  #endif
    char * arrn = "BBF82F090682CE9C2338AC2B9DA871F7368D07EED41043A440D6B6F07454F51FB8DFBAAF035C02AB61EA48CEEB6FCD4876ED520D60E1EC4619719D8A5B8B807FAFB8E0A3DFC737723EE6B4B7D93A2584EE6A649D060953748834B2454598394EE0AAB12D7B61A51F527A9A41F6C1687FE2537298CA2A8F5946F8E5FD091DBDCB";
    char * expo = "11";
    char * seedar  = "AAFD12F659CAE63489B479E5076DDEC2F06CB58F" ; 
    
    unsigned char plain[512], seed[128];
    size_t plain_len, seed_len ;
    rng_fake_ctx rng;
    
    unsigned char n[512];
    unsigned char e[8];
    
    br_rsa_public_key pk;

    pk.n = n;
    pk.nlen = hextobin(n, arrn);
    pk.e = e;
    pk.elen = hextobin(e, expo);
    unsigned char tmp[513];
    size_t len;

     plain_len  = BLOCK_SIZE;
    
     seed_len = hextobin(seed, seedar);
     
     // #ifdef CRY_DEBUG
     //  Serial.print("Seed :"); 
     //  Print(seed, seed_len, 0); 
     // #endif
     
      rng_fake_init(&rng, NULL, seed, seed_len);
      
     
      unsigned long start = millis();
      len = menc(&rng.vtable, &br_sha1_vtable, NULL, 0, &pk, tmp, sizeof tmp, plaintext, plain_len);
      unsigned long end = millis();
    
      
    #ifdef CRY_DEBUG
     if (len == 0 )
      Serial.println("Encryption failed ");
      
     else 
     {
         Serial.println("Encryption succeeded ");  
         Serial.println ("Encryptted key:"); 
       //  dbgPrint(tmp, len, 0);
         //strncpy((char *)output, (char*)tmp , );
         for (int i = 0 ; i<len; i++)
            output[i] = tmp[i]; 
     }
    
     Serial.println("<<<<<<<<<<<<<END RSA Encryption>>>>>>>>>>>>>>>>>>");  
    #endif
      #ifdef TIME_DEBUG
        if (len>0) {
        Serial.print(" Time to Encrypt the key using RSA:"); 
        Serial.println(end-start); 
        }
      #endif
    return len; 
  }

/* 
 *  adjust the length of the ciphered text
 */
void bufferSize(char* text, int &length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
}
/* 
 *  generate thge key
 */
void KeyGen()
{
  unsigned long b_kgen = millis();
  RNG::fill(key, BLOCK_SIZE);
  unsigned long e_kgen = millis();
   #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Generate the Symmetric Key in Ms:");
    Serial.print(timemsg); 
    Serial.println(e_kgen - b_kgen);
    #endif
  #ifdef CRY_DEBUG
   dbgPrint(key, BLOCK_SIZE,0); 
  #endif
}

void uninttochar(char * output,  uint8_t * input, int lenght)
{
    Serial.println(" line is "); 
    Serial.println(lenght); 
    char *  k = output; 
    for (int i = 0 ;i<lenght; i++) 
    { 
       Serial.print(i); 
       Serial.print(" >> ");
       Serial.println(input[i], HEX); 
       sprintf(k, "%02X",(uint8_t)input[i]); 
       k+=2;
    }
     k[lenght]= '\0';
}
/*
 * Encrypt message pt (plain text) using the defined key and store the encrypted inplace
 */
 void encryption(uint8_t * pt)
{
  uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

  br_aes_big_cbcenc_keys    ctx ; 
  #ifdef CRY_DEBUG_AES
  Serial.println("<<<<<<<<<<<<<<<start AES Encryption>>>>>>>>>>>>>>>>>");
  Serial.println(" Plain Text for AES");
  dbgPrint(pt,Size_Byte,Size_Byte-32);
  #endif
 
  br_aes_big_cbcenc_init(&ctx, key,BLOCK_SIZE ); 
  #ifdef OSLOENABLE
  digitalWrite(13, HIGH); 
  #endif
 unsigned long b_msenc  = millis();
 
  br_aes_big_cbcenc_run(&ctx,iv,  pt, Size_Byte);
    
 unsigned long e_msenc = millis();
 #ifdef OSLOENABLE
 digitalWrite(13, LOW);
 #endif
 #ifdef TIME_DEBUG
  char timemsg [50] ; 
  snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Encrypt the Data  using AES in Ms:");
  Serial.print(timemsg); 
  Serial.println(e_msenc - b_msenc);
 #endif
    
 #ifdef CRY_DEBUG_AES
  Serial.println(" Encryptted text by AES:");
  dbgPrint(pt,Size_Byte,Size_Byte-32);
  Serial.println("<<<<<<<<<<<<<<<End AES Encryption>>>>>>>>>>>>>>>>>");
  #endif
  }

/*
 * Decrypt the cipher text. 
 */
void aes_decryption(uint8_t * cipher)
{
  uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
  br_aes_big_cbcdec_keys    ctx ; 
  
  #ifdef CRY_DEBUG_AES
  Serial.println("<<<<<<<<<<<<<<<start AES Decryption>>>>>>>>>>>>>>>>>");
  Serial.println(" Cipher Text for AES:");
  dbgPrint(cipher,Size_Byte,0);
  #endif
 
  br_aes_big_cbcdec_init(&ctx, key,BLOCK_SIZE ); 
 unsigned long b_msdec = millis();
  br_aes_big_cbcdec_run(&ctx,iv,  cipher, Size_Byte);
  unsigned long e_msdec = millis();
  #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Decrypt the data using AES in Ms:");
    Serial.print(timemsg); 
    Serial.println(e_msdec - b_msdec);
    #endif
  #ifdef CRY_DEBUG_AES
  Serial.println(" Plain text from AES decryption:");
  dbgPrint(cipher,Size_Byte,0);
  Serial.println("<<<<<<<<<<<<<<<End Decryption>>>>>>>>>>>>>>>>>");
  #endif
  }
  



static uint8_t  *rand_string(uint8_t  *str, size_t size)
{
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
    if (size) {
        --size;
        for (size_t n = 0; n < size; n++) {
            int key = rand() % 16;
            str[n] = key;
        }
    }
    return str;
}

uint8_t * rand_string_alloc(size_t size)
{
     uint8_t  *s =(uint8_t  *) malloc(size);
     if (s) {
         rand_string(s, size);
     }
     return s;
}


void loop() {

  //Serial.println("START"); 

  if (!client.connected()) {
    reconnect();
  }
  
  
  unsigned long now = millis();
  if (now - lastMsg > 5000) {
    unsigned long t_b = millis();
    lastMsg = now;
    ++value;
  
    Datatransmission (value);
    KSdate(value);
    
    unsigned long t_e = millis();

    Serial.print("Time for whole process"); 
    Serial.println(t_e-t_b); 
   #ifdef RECON
   client.disconnect();
  #endif
  }
  

  

  client.loop();
}
void setup_wifi() {

  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  unsigned long b_conap= millis();
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

   unsigned long e_conap= millis();
  Serial.print(" Time to connect to Ap is :" );
  Serial.println(e_conap - b_conap);
  randomSeed(micros());

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}


void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Create a random client ID
    String clientId = "ESP8266Client-";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
     unsigned long b_conn = millis();
      #ifdef OSLOENABLE
      digitalWrite(13, HIGH);
      #endif
    if (client.connect(clientId.c_str())) {
      
      #ifdef OSLOENABLE
      digitalWrite(13, LOW);
      #endif
     unsigned long e_conn = millis();
      Serial.println("connected");
      digitalWrite(BUILTIN_LED, HIGH);
      #ifdef TIME_DEBUG
      Serial.print("Time to estiblsh connection in Ms is:");
      Serial.println(e_conn - b_conn);
      #endif
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}

void KSdate(int value)
{
     char * credintial = " KeyNote-Version: 2\n"\
           "Authorizer: \"RSA:dab212\" \n" \     
           "Licensees: \"DSA:feed1234\" \n"\
           "Conditions: (app_domain==\"KS\")-> { (Process) < 2500) -> _MAX_TRUST; Signature: ";
     int siglen = 128 ; 
    unsigned char signnature [siglen]; 

    //sign the credintial 
    rsa_sign(credintial, signnature,  &br_rsa_i15_pkcs1_sign);
    delay(5000); 
     
     
     unsigned char cipher[513] ={0};

     int len = rsa_encrypt(key, cipher, &br_rsa_i15_oaep_encrypt);

    #ifdef DEBUG
     Serial.print("Encryptted Key:");
     dbgPrint (cipher, len , 0); 
     #endif
    
    int length =  len + siglen + strlen(credintial); 
    
    unsigned char MSG[length]; 
    
    memcpy((unsigned char *)MSG, (unsigned char *)cipher, len); 
    memcpy((unsigned char *)MSG+len ,(unsigned char *)signnature, siglen); 
     memcpy(MSG+len +siglen, credintial, strlen(credintial)); 
    
    
   // #ifdef DEBUG
    Serial.println("KEY  and Cred:"); 
    dbgPrint((uint8_t *)MSG, length, 0); 
   // #endif
    
    unsigned long b_kmsend = millis();
    #ifdef OSLOENABLE
    digitalWrite(13, HIGH);
    #endif
    client.beginPublish("mhh_sec_key", length, true); 
    client.write((byte *)MSG, length); 
    client.endPublish ();
    
    #ifdef OSLOENABLE
    digitalWrite(13, LOW);
    #endif
   unsigned long e_kmsend = millis();
   #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Send the  %D key in Ms:", value);
    Serial.print(timemsg); 
    Serial.println(e_kmsend - b_kmsend);
    #endif
    
   
 }



 void KSdate_noenc()
{

    
    unsigned char cipher[513] = {0};
    
    Serial.print("Session Key:");
    dbgPrint (key, 16, 0); 

      client.beginPublish("mhh_sec_key",8, true); 
      client.write((unsigned char *)key,8); 
      client.endPublish ();

delay(1000); 

    int len = rsa_encrypt(key, cipher, &br_rsa_i15_oaep_encrypt);

    delay(1000); 
/*
    Serial.print("Encryptted Key:");
    dbgPrint (cipher, len, 0); 

*/
      client.beginPublish("mhh_sec_key",16, true); 
      client.write((unsigned char *)key,16); 
      client.endPublish ();

   


 }


 void Datatransmission(int value)
 {
    //int length = 0 ; 
    //bufferSize(mymsg, length);

    
    encryption(mymsg);
   
    unsigned long b_msgsend = millis();
    #ifdef OSLOENABLE
    digitalWrite(13, HIGH);
    #endif
    client.beginPublish("mhh_my_topic", Size_Byte, true); 
    client.write((byte *)mymsg, (int)Size_Byte); 
    client.endPublish ();
    #ifdef OSLOENABLE
    digitalWrite(13, LOW);
    #endif
    unsigned long e_msgsend = millis();

    //snprintf (msg, MSG_BUFFER_SIZE, "Message ID #%ld ", value );
    //Serial.print("Publish message: ");
    //Serial.println(msg);
    #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Send %ld Byte in Ms:", Size_Byte );
    Serial.print(timemsg); 
    Serial.println(e_msgsend - b_msgsend);
    #endif
  }
 
 void Datatransmission_16(int value)
 {
    //int length = 0 ; 
    //bufferSize(mymsg, length);
    uint8_t msg[BLOCK_SIZE] = { 1, 3, 5, 7, 9, 0, 2, 4, 6, 8,1, 4, 6, 8, 3, 5 };
    
    encryption(msg);
   
    unsigned long b_msgsend = millis();
    #ifdef OSLOENABLE
    digitalWrite(13, HIGH);
    #endif
    client.beginPublish("mhh_my_topic", BLOCK_SIZE, true); 
    client.write((byte *)msg, (int)BLOCK_SIZE); 
    client.endPublish ();
    #ifdef OSLOENABLE
    digitalWrite(13, LOW);
    #endif
    unsigned long e_msgsend = millis();

    //snprintf (msg, MSG_BUFFER_SIZE, "Message ID #%ld ", value );
    //Serial.print("Publish message: ");
    //Serial.println(msg);
    #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to Send %ld Byte in Ms:", Size_Byte );
    Serial.print(timemsg); 
    Serial.println(e_msgsend - b_msgsend);
    #endif
  
  }
  
/*
 * Print array
 * size: the size of the array 
 * beg: index to start printing 
 */
  void dbgPrint(uint8_t * arr, int size, int beg)
{
  Serial.println();
  int start = beg; //defualt = 0
  int row =0 ;
  Serial.print(row); 
  Serial.print(" >> ");  
  for (int i =start; i<size; i++)
  {
     if(i> 0 && i % BLOCK_SIZE ==0)
     {
      row++;
      Serial.println(); 
      Serial.print(row); 
      Serial.print(" >> ");
      
     }
    Serial.print(arr[i],HEX); 
    Serial.print(" "); 
   
  }
  Serial.println();
    
  }

  
  void hw_wdt_disable(){
  *((volatile uint32_t*) 0x60000900) &= ~(1); // Hardware WDT OFF
}

void hw_wdt_enable(){
  *((volatile uint32_t*) 0x60000900) |= 1; // Hardware WDT ON
}
  
void setup() {
  //pinMode(BUILTIN_LED, OUTPUT);     // Initialize the BUILTIN_LED pin as an output
  pinMode(13, OUTPUT);
  Serial.begin(115200);

  /*
  ESP.wdtDisable();
  hw_wdt_disable();
  */
  
  setup_wifi();
  mymsg = rand_string_alloc(Size_Byte);
  client.setServer(mqtt_server, mqttPort);
}
