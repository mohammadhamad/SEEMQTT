#include <WiFi.h>
#include <SecMqttKSn_ibe.h>

/* print the time measurment */
#define TIME_DEBUG
#define DBG_MSG


/* by enable that we enforrce the connection to be closed after each transmission */
//#define RECON
#define Size_Byte 1024

//Update these with values suitable for your network.
const char* ssid = "TP-Link_904A";
const char* password = "30576988";
const char* mqtt_server = "192.168.0.102";

const int mqttPort = 1883;
const char* topic = "iot_data";
String clientId = "ESP32Client-";
unsigned long lastMsg = 0;
unsigned char* mymsg;

int test_times = 1;


/*
 * Key Store Public key
 */

// Note:
// 1. IBE: give identity
// 2. SSS:
// load file

const char ks_ibe_id1[] = "keystore1@tum.com";
const char ks_ibe_id2[] = "keystore2@tum.com";
const char ks_ibe_id3[] = "keystore3@tum.com";
//const char ks_ibe_id4[] = "keystore4@tum.com";
//const char ks_ibe_id5[] = "keystore5@tum.com";

/*
 * IOT RSA public and private keys generated by openssl
 */

/* public key 1024 bit */
const unsigned char iot_pk_key[]= \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC007GfgttefDhYI5Mcv7IrPlWp\n" \
"62tCsqBdcfP/UqneljzLl0uk+1sSMCvR7oCtL+kZcCDbkbv4CjFCKkuhwebZ7YNM\n" \
"TRJ6ws37emQfS8IM7XRlYaIQmmOacDvFFjrWBd0pYKXnP8ZnBSPVmKHu8as+mz0i\n" \
"7BnKdUGhRn9atFzZDQIDAQAB\n" \
"-----END PUBLIC KEY-----\n";


const unsigned char iot_pr_key[]= \
"-----BEGIN RSA PRIVATE KEY-----\n" \
"MIICXAIBAAKBgQCofOr6q5UU8if7sSsdLoXTZCMXX2l4QOTRaTdDiZOcDQkrGXD7\n" \
"/76MDj+MA+agJ56Qu0iarlI0BOirvcmT/Ld9W1OQBVWe7/IwSeD9Kgqd8t+CTArj\n" \
"bGOvtx52QLiaXTfWNks7eixmkaDB60C/xVfjCT/E4md/itQq0p22Toyc3wIDAQAB\n" \
"AoGAbGtV2dAnsr7Qs8mh8LlLLGg3nIatG9DGbWrDQRZ6geRxjeZlKgO73ewdQEAS\n" \
"W+SiyId7hO2/v/GYt0r9N9lbSKeXw23el7fbyrt6aytK9oolzhojUhi4blZsTd39\n" \
"DVWSPII/0718BYGzD+UPU0PfMKKLu00EWvrVuxcBSYyGtcECQQDbX0jWAMBCTnaF\n" \
"kAFTBZ6HY78A0ZTbl3q44bKccs2KvmdO1CPIAgvrbQJekurLQ6/wx1DfbUBb9JmI\n" \
"VcrmqjPZAkEAxJ6q2cBOT08Qh3W62inF6hwE848XkVc/qN8ud2gv04VkMWy2V+mZ\n" \
"9wgnOxkOoEVd2ESZ1nKDXtlpokyUB6e7dwJAZmrc8XSWTh6dvQuXYrBb6+/Iq9Qt\n" \
"QDw/gnN01Q/QIHd2edoW/njeIcLZ+Vd0IQPv72TOwBEcnBHdYEZVnU1XOQJACmFm\n" \
"G8DvYXiHIt+wUbxK2qVIDaPMVrwIfF3sEhnKDJzKQWG/7rxCiKxBhfk4sHV5EuXs\n" \
"SUoabXOFBDCO0Cim2QJBAJ+GFjpE2IASX6x4mlpBlYEuqHVlP+h7gjHPqtg7amuE\n" \
"n2O9KxEK8KmZoyxan7lmvdDa/fwEIQ6MEG7On40ckas=\n" \
"-----END RSA PRIVATE KEY-----\n";


const unsigned char cr[] = \
"Authorizer: \"rsa-hex:30818902818100a87ceafaab9514f227fbb12b1d\\\n" \
"            2e85d36423175f697840e4d169374389939c0d092b1970fbf\\\n" \
"            fbe8c0e3f8c03e6a0279e90bb489aae523404e8abbdc993fc\\\n" \
"            b77d5b539005559eeff23049e0fd2a0a9df2df824c0ae36c6\\\n" \
"            3afb71e7640b89a5d37d6364b3b7a2c6691a0c1eb40bfc557\\\n" \
"            e3093fc4e2677f8ad42ad29db64e8c9cdf0203010001\"\n" \
"Licensees: \"rsa-hex:30818902818100f111cf4d75b5f36bdedd5968d5\\\n" \
"            9be24cb959bc74eb61a1006d2e02425264c5f5b7334eba322\\\n" \
"            ee6a9f40268967c9e390820e415b3de75c6b48280b037b36a\\\n" \
"            48a9b16051b2f88273b6e0f90fc528ad94164b968cd077249\\\n" \
"            6fb40b86501846adfe4d21fc2ab45f7f50742e2f513519d0b\\\n" \
"            095740e13261f92b3742ad056b71cb20d30203010001\"\n"\
"Delegate: 1\n"\
"Conditions: topic == \"car_loc\" && location == \"munich\" -> \"authorized\";\n"\
"signature:";

WiFiClient espClient;
SecMqtt mqttclient(espClient);

/*
 * call plattform-specific  TRNG driver
 */
static int myrand(void *rng_state, unsigned char *output, size_t len)
{
    size_t olen;
    return mbedtls_hardware_poll(rng_state, output, len, &olen);
}


/*
 *  adjust the length of the ciphered text
 */
void bufferSize(char* text, int &length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  // length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
  length = (buf <= i) ? buf + BLOCK_SIZE : buf;
}

/*
* rand_string:  fill a memeory with ranom values
*/
static uint8_t  *rand_string(uint8_t  *str, size_t size) {
  const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
  if (size) {
    --size;
    for (size_t n = 0; n < size; n++) {
      int key = rand() % 16;
      str[n] = key;
    }
  }
  return str;
}

/*
Allocate memory and fill it with random value. size determines the size of the required memeory
*/
uint8_t* rand_string_alloc(size_t size) {
  uint8_t* s =(uint8_t  *) malloc(size);
  if (s) {
    rand_string(s, size);
  }
  return s;
}


void setup_wifi() {
    delay(10);

    Serial.println();
    Serial.print("Connecting to ");
    Serial.println(ssid);

    WiFi.begin(ssid, password);
    unsigned long b_conap= micros();
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    unsigned long e_conap= micros();
    Serial.printf(" Time to connect to AP is : %lu (us) \n",e_conap - b_conap );

    randomSeed(micros());

    Serial.println("");
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());
}


void reconnect() {
    // Loop until we're reconnected
    while (!mqttclient.connected()) {
        Serial.print("Attempting MQTT connection...");

        mqttclient.SecConnect(clientId.c_str());
        delay(5000);
    }
}


/*
 * Print array
 * size: the size of the array
 * beg: index to start printing
 */
void dbgPrint(uint8_t * arr, int beg ,int size) {
  Serial.println();
  int start = beg; //defualt = 0
  int row = 0 ;
  Serial.print(row);
  Serial.print(" >> ");
  for (int i = start; i < size; i++)
  {
     if(i > 0 && i % BLOCK_SIZE == 0)
     {
      row++;
      Serial.println();
      Serial.print(row);
      Serial.print(" >> ");
     }
    Serial.print(arr[i], HEX);
    Serial.print(" ");
  }
  Serial.println();
}

void setup() {
  Serial.begin(115200);
  setup_wifi();
  mymsg = rand_string_alloc(Size_Byte);

  clientId += String(random(0xffff), HEX);
  mqttclient.setServer(mqtt_server, mqttPort);

  Serial.println("set keys....");
  mqttclient.secmqtt_set_iot_pk_key(iot_pk_key, (int)sizeof(iot_pk_key));
  mqttclient.secmqtt_set_iot_pr_key(iot_pr_key, (int)sizeof(iot_pr_key));
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id1, strlen(ks_ibe_id1),1);
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id2, strlen(ks_ibe_id2),2);
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id3, strlen(ks_ibe_id3),3);
 // mqttclient.secmqtt_set_ibe_id(ks_ibe_id4, strlen(ks_ibe_id4),4);
 // mqttclient.secmqtt_set_ibe_id(ks_ibe_id5, strlen(ks_ibe_id5),5);
  mqttclient.secmqtt_set_enc_mode("ibe");
  mqttclient.secmqtt_set_secret_share_mode("sss");

  mqttclient.secmqtt_set_iot_credential(cr, (int) sizeof(cr));

  /*
   * 1. connection to Key Store will be done only once during setup
   * 2. session key will be updated once during setup
   */
  mqttclient.SecConnect(clientId.c_str());

}

void loop() {

  if (!mqttclient.connected()) {
    reconnect();
  }

  unsigned long now = millis();
  if (now - lastMsg > 10000) {
    lastMsg = now;

    if(mqttclient.get_state() == SECMQTT_KS_CONNECTED) {
        Serial.printf("test %d\n", test_times);
        char * txt = "Hello world hii";
        int mlen = 16 ;
        //mqttclient.SecPublish(topic, mymsg, Size_Byte);
        mqttclient.SecPublish(topic, (unsigned char *) txt, mlen);
        test_times += 1;
    }
    else {
        mqttclient.SecConnect(clientId.c_str());
    }

    #ifdef RECON
     mqttclient.disconnect();
    #endif
  }

  mqttclient.loop();
}
