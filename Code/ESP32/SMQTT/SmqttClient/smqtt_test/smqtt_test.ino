#include <WiFi.h>
#include <SecMqtt.h>

/* print the time measurment */ 
#define TIME_DEBUG

#define BUILTIN_LED 2 

/* by enable that we enforrce the connection to be closed after each transmission */
//#define RECON

#define BLOCK_SIZE 16 // aes key 128 bits
#define Size_Byte 16 // message payload size
#define C_SIZE 128 // rsa encryption message size

unsigned char* mymsg;

/*
 * Key Store Public key 
 */
const unsigned char  ks_pk_key[] = \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCzvn02mL6PeS0HV4LNogcu545e\n" \
"+rQKo0MLpRv3EbkVL3p1HIb6JdYfEzyTeMfwSDS+P1/9o7SQ796mYacLtIqEvQ5K\n" \
"ppkqv1CRYQYds2kh/tWmqVEulCOPMu1TmWxpaxGt3mEAwM+FX0FUjnpFSC+P83aO\n" \
"o+74Z+8G/ivvfbXRcQIDAQAB\n" \
"-----END PUBLIC KEY-----\n";


/*
 * IOT RSA public and prrivate keys generated by openssl 
 */

/* public key 1024 bit */
const unsigned char iot_pk_key[]= \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC007GfgttefDhYI5Mcv7IrPlWp\n" \
"62tCsqBdcfP/UqneljzLl0uk+1sSMCvR7oCtL+kZcCDbkbv4CjFCKkuhwebZ7YNM\n" \
"TRJ6ws37emQfS8IM7XRlYaIQmmOacDvFFjrWBd0pYKXnP8ZnBSPVmKHu8as+mz0i\n" \
"7BnKdUGhRn9atFzZDQIDAQAB\n" \
"-----END PUBLIC KEY-----\n";

const unsigned char iot_pr_key[]= \
"-----BEGIN RSA PRIVATE KEY-----\n" \
"MIICXAIBAAKBgQC007GfgttefDhYI5Mcv7IrPlWp62tCsqBdcfP/UqneljzLl0uk\n" \
"+1sSMCvR7oCtL+kZcCDbkbv4CjFCKkuhwebZ7YNMTRJ6ws37emQfS8IM7XRlYaIQ\n" \
"mmOacDvFFjrWBd0pYKXnP8ZnBSPVmKHu8as+mz0i7BnKdUGhRn9atFzZDQIDAQAB\n" \
"AoGAU75CYXwJug1PTspS5BqHGe3JYGMNjpsJF52hgVo4H0R2rVbJCoP53kd+079f\n" \
"ylUI3+YE4YrxgWK/A0RxOF2DWhusL0MAUdg2sSDf9htfiCbflBD0scYFXCLQOr+9\n" \
"3GNoNIv5nPIzuqDCTbr7leAQTJfYGoz5rlcfd7s99astOkECQQDsn8fyi12I2sHc\n" \
"LkA5DngTq/z3M0cTRxhU0Bh1Hge2H2eJTZRjaD5GXnEjZvFmDU/7luUJYUzxyTYY\n" \
"IgH68Hy9AkEAw6JEYjlFqFaXPOHcyNEoRsk8J5cXGofwY4ABaifYg+EU9o9vs0+I\n" \
"8DCzyrRZbU0jt/GX8zvXJEuhxck5+pcakQJBAOv5aEBUhcHuTvhSU4/TAyKzGQI5\n" \
"a/8onnYuVMWvXgddCDbgXERKeBhbJL8mcUTRr9r6H40cMMzLWZv1hj4HyI0CQD50\n" \
"PRSGaCB3lEyRZmSNsSf38kZJS8zifPGm2czD77EaWBDmdahuya60PZGGxc3JBJAi\n" \
"hnnWLradloWH2gSP3KECQB2GGMO2Lpjvn1d2Zcpf/r4TpYYa5LbQ9sBIUyj+Obvs\n" \
"H3JAp8zyNQe3mFnp64DI3y0wB95+lU0EULtL95DhYvk=\n" \
"-----END RSA PRIVATE KEY-----\n";

/* credential for smqtt communication */
const unsigned char cred[] = \
      "KeyNote-Version: 2\n" \
      "Authorizer: \"RSA:dab212\" \n" \
      "Licensees: \"DSA:feed1234\" \n" \
      "Conditions: (app_domain==\"KS\")-> { (Process) < 2500) -> _MAX_TRUST; Signature: ";


// Update these with values suitable for your network.
const char* ssid = "Commodore64";
const char* password = "ma0s#verSuch";
const char* mqtt_server =  "192.168.178.38";
const int mqttPort = 1883; 
const char* topic = "mhh_my_topic";
String clientId = "ESP32Client-";
unsigned long lastMsg = 0;

WiFiClient espClient;
SecMqtt mqttclient(espClient);

/*
 * call plattform-specific  TRNG driver
 */
static int myrand(void *rng_state, unsigned char *output, size_t len)
{
    size_t olen;
    return mbedtls_hardware_poll(rng_state, output, len, &olen);
}


/* 
 *  adjust the length of the ciphered text
 */
void bufferSize(char* text, int &length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  // length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
  length = (buf <= i) ? buf + BLOCK_SIZE : buf;
}

static uint8_t  *rand_string(uint8_t  *str, size_t size) {
  const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
  if (size) {
    --size;
    for (size_t n = 0; n < size; n++) {
      int key = rand() % 16;
      str[n] = key;
    }
  }
  return str;
}

uint8_t* rand_string_alloc(size_t size) {
  uint8_t* s =(uint8_t  *) malloc(size);
  if (s) {
    rand_string(s, size);
  }
  return s;
}


void setup_wifi() {
  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  unsigned long b_conap= micros();

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  unsigned long e_conap= micros();
  Serial.print(" Time to connect to AP is :" );
  Serial.print(e_conap - b_conap);
  Serial.println(" (us)"); 
  randomSeed(micros());

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}


void reconnect() {
  
    // Loop until we're reconnected
    while (!mqttclient.connected()) {
        Serial.print("Attempting MQTT connection...");
        
        unsigned long b_conn = micros();
        if (mqttclient.connect(clientId.c_str())) {
            unsigned long e_conn = micros();
            Serial.println("connected");
            
            #ifdef TIME_DEBUG
            Serial.print("Time to estiblsh connection with server is:");
            Serial.print(e_conn - b_conn);
            Serial.println(" (us)"); 
            #endif
        } else {
            Serial.print("failed, rc=");
            Serial.print(mqttclient.state());
            Serial.println(" try again in 5 seconds");
            delay(5000);
    }
  }
}

/*
 * Print array
 * size: the size of the array 
 * beg: index to start printing 
 */
void dbgPrint(uint8_t * arr, int beg ,int size) {
  Serial.println();
  int start = beg; //defualt = 0
  int row = 0 ;
  Serial.print(row); 
  Serial.print(" >> ");  
  for (int i = start; i < size; i++)
  {
     if(i > 0 && i % BLOCK_SIZE == 0)
     {
      row++;
      Serial.println(); 
      Serial.print(row); 
      Serial.print(" >> ");
     }
    Serial.print(arr[i], HEX); 
    Serial.print(" "); 
  }
  Serial.println();
}

void setup() {
  //pinMode(BUILTIN_LED, OUTPUT);     // Initialize the BUILTIN_LED pin as an output
  pinMode(13, OUTPUT);
  Serial.begin(115200);

  setup_wifi();
  mymsg = rand_string_alloc(Size_Byte);

  clientId += String(random(0xffff), HEX);
  mqttclient.setServer(mqtt_server, mqttPort);
  mqttclient.connect(clientId.c_str());
  
  Serial.println("set keys");
  mqttclient.secmqtt_set_ks_pk_key(ks_pk_key, (unsigned int)sizeof(ks_pk_key));
  mqttclient.secmqtt_set_iot_pk_key(iot_pk_key, (unsigned int)sizeof(iot_pk_key));
  mqttclient.secmqtt_set_iot_pr_key(iot_pr_key, (unsigned int)sizeof(iot_pr_key));
  mqttclient.secmqtt_set_cred(cred);

  /* 1. connection to Key Store will be done only once during setup 
   * 2. session key will be updated once during setup
   */
  unsigned long se_b = micros();
  mqttclient.SecConnect();
  unsigned long se_e = micros();
  Serial.printf("Phase 1 takes: %ld (us) \n", se_e - se_b);
  mqttclient.SecSessionKeyUpdate();
}

void loop() {
  
  if (!mqttclient.connected()) {
    reconnect();

     /* a new session key will be generated after a 
      * reconnection to the broker
      */
    mqttclient.SecSessionKeyUpdate();
  }

  unsigned long now = millis();
  if (now - lastMsg > 3000) {
    lastMsg = now;

    if(mqttclient.get_state() == SECMQTT_KS_CONNECTED) {

        /* one session key can only be used for e.g. 20 times by default
         * then a session key update will be performed 
         */
        Serial.println("Start Secure MQTT Publishing ...");
        mqttclient.SecPublish(topic, mymsg, Size_Byte);
        Serial.println("finished Publish!");
    } else {
        Serial.println("Secure connecting to Key Store ...");
        unsigned long t_b = micros();
        mqttclient.SecConnect();
        unsigned long t_e = micros();
        Serial.print("Time for setup Key Store connection: ");
        Serial.print(t_e - t_b);
        Serial.println(" (us)");
    }

    #ifdef RECON
    mqttclient.disconnect();
    #endif
  }
  
  mqttclient.loop();
}
