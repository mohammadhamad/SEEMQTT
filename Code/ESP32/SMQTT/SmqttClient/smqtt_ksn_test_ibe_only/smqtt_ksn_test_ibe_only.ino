#include <WiFi.h>
#include <SecMqttKSn_ibe.h>

/* print the time measurment */ 
#define TIME_DEBUG
#define DBG_MSG

#define BUILTIN_LED 2 

/* by enable that we enforrce the connection to be closed after each transmission */
//#define RECON

#define Size_Byte 1024

// Update these with values suitable for your network.
const char* ssid = "TP-Link_904A";
const char* password = "30576988";
const char* mqtt_server = "192.168.0.110"; 

const int mqttPort = 1883; 
const char* topic = "mhh_my_topic";
String clientId = "ESP32Client-";
unsigned long lastMsg = 0;
unsigned char* mymsg;

int test_times = 1;


/*
 * Key Store Public key 
 */

// Note:
// 1. IBE: give identity
// 2. SSS:
// load file

const char ks_ibe_id1[] = "keystore1@tum.com";
const char ks_ibe_id2[] = "keystore2@tum.com";
const char ks_ibe_id3[] = "keystore3@tum.com";
//const char ks_ibe_id4[] = "keystore4@tum.com";
//const char ks_ibe_id5[] = "keystore5@tum.com";

/*
 * IOT RSA public and private keys generated by openssl 
 */

/* public key 1024 bit */
const unsigned char iot_pk_key[]= \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC007GfgttefDhYI5Mcv7IrPlWp\n" \
"62tCsqBdcfP/UqneljzLl0uk+1sSMCvR7oCtL+kZcCDbkbv4CjFCKkuhwebZ7YNM\n" \
"TRJ6ws37emQfS8IM7XRlYaIQmmOacDvFFjrWBd0pYKXnP8ZnBSPVmKHu8as+mz0i\n" \
"7BnKdUGhRn9atFzZDQIDAQAB\n" \
"-----END PUBLIC KEY-----\n";

const unsigned char iot_pr_key[]= \
"-----BEGIN RSA PRIVATE KEY-----\n" \
"MIICXAIBAAKBgQC007GfgttefDhYI5Mcv7IrPlWp62tCsqBdcfP/UqneljzLl0uk\n" \
"+1sSMCvR7oCtL+kZcCDbkbv4CjFCKkuhwebZ7YNMTRJ6ws37emQfS8IM7XRlYaIQ\n" \
"mmOacDvFFjrWBd0pYKXnP8ZnBSPVmKHu8as+mz0i7BnKdUGhRn9atFzZDQIDAQAB\n" \
"AoGAU75CYXwJug1PTspS5BqHGe3JYGMNjpsJF52hgVo4H0R2rVbJCoP53kd+079f\n" \
"ylUI3+YE4YrxgWK/A0RxOF2DWhusL0MAUdg2sSDf9htfiCbflBD0scYFXCLQOr+9\n" \
"3GNoNIv5nPIzuqDCTbr7leAQTJfYGoz5rlcfd7s99astOkECQQDsn8fyi12I2sHc\n" \
"LkA5DngTq/z3M0cTRxhU0Bh1Hge2H2eJTZRjaD5GXnEjZvFmDU/7luUJYUzxyTYY\n" \
"IgH68Hy9AkEAw6JEYjlFqFaXPOHcyNEoRsk8J5cXGofwY4ABaifYg+EU9o9vs0+I\n" \
"8DCzyrRZbU0jt/GX8zvXJEuhxck5+pcakQJBAOv5aEBUhcHuTvhSU4/TAyKzGQI5\n" \
"a/8onnYuVMWvXgddCDbgXERKeBhbJL8mcUTRr9r6H40cMMzLWZv1hj4HyI0CQD50\n" \
"PRSGaCB3lEyRZmSNsSf38kZJS8zifPGm2czD77EaWBDmdahuya60PZGGxc3JBJAi\n" \
"hnnWLradloWH2gSP3KECQB2GGMO2Lpjvn1d2Zcpf/r4TpYYa5LbQ9sBIUyj+Obvs\n" \
"H3JAp8zyNQe3mFnp64DI3y0wB95+lU0EULtL95DhYvk=\n" \
"-----END RSA PRIVATE KEY-----\n";


unsigned char iotpk[] = "KeyNote-Version: 2\nAuthorizer: \"rsa-hex:30818902818100c5465a29ab554d22b5eac414a0\\\n" \
"            4e75c5e37690c2759e7bba9c33596d5010bd8e5c8be2c1b59\\\n" \
"            c939152ce952beb6ca678878c0a0735216e76c00b9ef1fb43\\\n" \
"            434eeebdd4f1b195109cde01e6e24e23cd49ea66fe8dd30e4\\\n" \
"            ac18ba4ca411229a7d1bc473d072bfd602f0b9bed74e255b8\\\n" \
"            9c374e8f3a3dc0de1bc7b49ff9708f4a470203010001\"\n" ;
unsigned char capk[]  = "Licensees:  \"rsa-hex:30818902818100ca4487e0d985cf784c60dd1b06\\\n" \
"            88f37d6f87fb8ced72a44f64c18e732a4a3b31dedb80df96f\\\n" \
"            2e341fd4fbeed89e86bdd87c8982a6cbeb80e6f433f1a8e89\\\n" \
"            e8f285ef8c4f5271aa9512635c2cc3bd37d758fcdf47aeb85\\\n" \
"            8a89cb0e6597de08665dd82300a20fd8e7e8b529eeadebc88\\\n" \
"            0a885761d12f8dcf03c54cf95ea67418050203010001\"\n Delegate: 0\n" ;
unsigned char Conditions[] ="topic == \"t1\" && location == \"l1\" -> \"authorized\";\n Signature: " ;


const unsigned char cr[] = \
"KeyNote-Version: 2\n"\
"Authorizer: \"rsa-hex:30818902818100c5465a29ab554d22b5eac414a0\\\n" \
"            4e75c5e37690c2759e7bba9c33596d5010bd8e5c8be2c1b59\\\n" \
"            c939152ce952beb6ca678878c0a0735216e76c00b9ef1fb43\\\n" \
"            434eeebdd4f1b195109cde01e6e24e23cd49ea66fe8dd30e4\\\n" \
"            ac18ba4ca411229a7d1bc473d072bfd602f0b9bed74e255b8\\\n" \
"            9c374e8f3a3dc0de1bc7b49ff9708f4a470203010001\"\n" \
"Licensees:  \"rsa-hex:30818902818100ca4487e0d985cf784c60dd1b06\\\n" \
"            88f37d6f87fb8ced72a44f64c18e732a4a3b31dedb80df96f\\\n" \
"            2e341fd4fbeed89e86bdd87c8982a6cbeb80e6f433f1a8e89\\\n" \
"            e8f285ef8c4f5271aa9512635c2cc3bd37d758fcdf47aeb85\\\n" \
"            8a89cb0e6597de08665dd82300a20fd8e7e8b529eeadebc88\\\n" \
"            0a885761d12f8dcf03c54cf95ea67418050203010001\"\n" \
"Delegate: 1\n"\
"Conditions: topic == \"t1\" && location == \"l1\" -> \"authorized\";\n"\
"Signature: ";

WiFiClient espClient;
SecMqtt mqttclient(espClient);

/*
 * call plattform-specific  TRNG driver
 */
static int myrand(void *rng_state, unsigned char *output, size_t len)
{
    size_t olen;
    return mbedtls_hardware_poll(rng_state, output, len, &olen);
}


/* 
 *  adjust the length of the ciphered text
 */
void bufferSize(char* text, int &length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  // length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
  length = (buf <= i) ? buf + BLOCK_SIZE : buf;
}

static uint8_t  *rand_string(uint8_t  *str, size_t size) {
  const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
  if (size) {
    --size;
    for (size_t n = 0; n < size; n++) {
      int key = rand() % 16;
      str[n] = key;
    }
  }
  return str;
}

uint8_t* rand_string_alloc(size_t size) {
  uint8_t* s =(uint8_t  *) malloc(size);
  if (s) {
    rand_string(s, size);
  }
  return s;
}


void setup_wifi() {
    delay(10);
    
    Serial.println();
    Serial.print("Connecting to ");
    Serial.println(ssid);

    WiFi.mode(WIFI_STA);
    WiFi.setSleep(false);
    WiFi.begin(ssid, password);
    unsigned long b_conap= micros();

    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }

    unsigned long e_conap= micros();
    Serial.print(" Time to connect to AP is :" );
    Serial.print(e_conap - b_conap);
    Serial.println(" (us)"); 
    randomSeed(micros());

    Serial.println("");
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());
}


void reconnect() {
  
    // Loop until we're reconnected
    while (!mqttclient.connected()) {
        Serial.print("Attempting MQTT connection...");

        mqttclient.SecConnect(clientId.c_str());
        delay(5000);
    }
}


/*
 * Print array
 * size: the size of the array 
 * beg: index to start printing 
 */
void dbgPrint(uint8_t * arr, int beg ,int size) {
  Serial.println();
  int start = beg; //defualt = 0
  int row = 0 ;
  Serial.print(row); 
  Serial.print(" >> ");  
  for (int i = start; i < size; i++)
  {
     if(i > 0 && i % BLOCK_SIZE == 0)
     {
      row++;
      Serial.println(); 
      Serial.print(row); 
      Serial.print(" >> ");
     }
    Serial.print(arr[i], HEX); 
    Serial.print(" "); 
  }
  Serial.println();
}

void setup() {
  //pinMode(BUILTIN_LED, OUTPUT);     // Initialize the BUILTIN_LED pin as an output
  pinMode(13, OUTPUT);
  Serial.begin(115200);

  setup_wifi();
  mymsg = rand_string_alloc(Size_Byte);

  clientId += String(random(0xffff), HEX);
  
  mqttclient.setServer(mqtt_server, mqttPort);

  Serial.println("set keys");
  
  mqttclient.secmqtt_set_iot_pk_key(iot_pk_key, (int)sizeof(iot_pk_key));
  mqttclient.secmqtt_set_iot_pr_key(iot_pr_key, (int)sizeof(iot_pr_key));
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id1, strlen(ks_ibe_id1),1);
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id2, strlen(ks_ibe_id2),2);
  mqttclient.secmqtt_set_ibe_id(ks_ibe_id3, strlen(ks_ibe_id3),3);
 // mqttclient.secmqtt_set_ibe_id(ks_ibe_id4, strlen(ks_ibe_id4),4);
 // mqttclient.secmqtt_set_ibe_id(ks_ibe_id5, strlen(ks_ibe_id5),5);
  mqttclient.secmqtt_set_enc_mode("ibe");
  mqttclient.secmqtt_set_secret_share_mode("sss");

  mqttclient.secmqtt_set_iot_credential(cr, (int) sizeof(cr)); 


  /* 
   * 1. connection to Key Store will be done only once during setup 
   * 2. session key will be updated once during setup
   */
  mqttclient.SecConnect(clientId.c_str());

  #ifdef TIME_DEBUG
  // phase1: connect to broker + tenc + tsend + tothers
  // phase2: max(trecv) 

  /* tack1 = keystore: tdec + tenc + tsend + tothers
   * 
   * 
     tks1 = tack1 + tdec + tcmp done
     tks2 = tack2 + tdec + tcmp done
     tks3 = tack3 + tdec + tcmp done
  */
  
  Serial.printf("time connect: \t\t%lu (us)\n", mqttclient.time_info.t_connect);
  Serial.printf("time enc: \t\t%lu (us)\n", mqttclient.time_info.t_enc);
  Serial.printf("time send: \t\t%lu (us)\n", mqttclient.time_info.t_send_pk);
  Serial.printf("time phase 1: \t\t%lu (us)\n", mqttclient.time_info.t_p11 + mqttclient.time_info.t_connect);

  for (int i = 0; i < KSN_NUM; i++) {
    Serial.printf("time receive ack%d: \t%lu (us)\n", i+1, mqttclient.time_info.t_recv[i]);
  }

  Serial.printf("time dec: \t\t%lu (us)\n", mqttclient.time_info.t_dec);
  Serial.printf("time phase 2: \t\t%lu (us)\n", mqttclient.time_info.t_p2);
  Serial.printf("time phase 1+2: \t\t%lu (us)\n", mqttclient.time_info.t_p2+mqttclient.time_info.t_p11 + mqttclient.time_info.t_connect);
  #endif
}

void loop() {
  
  if (!mqttclient.connected()) {
    reconnect();
  }

  unsigned long now = millis();
  if (now - lastMsg > 3000) {
    lastMsg = now;

    if(mqttclient.get_state() == SECMQTT_KS_CONNECTED) {
        Serial.printf("test %d\n", test_times);
        mqttclient.SecPublish(topic, mymsg, Size_Byte);
        test_times += 1;
    } else {
        mqttclient.SecConnect(clientId.c_str());
    }

    #ifdef RECON
    mqttclient.disconnect();
    #endif
  }
  
  mqttclient.loop();
}
