#include <WiFi.h>
#include <PubSubClient.h>

//for AES block cipher and rsa  
#include "mbedtls/pk.h"
#include "mbedtls/rsa.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/x509_crt.h"
#include "mbedtls/entropy_poll.h"

#include "mbedtls/aes.h"

/* Debug the code */
//#define DBG_PRINT

/* print the time measurment */ 
#define TIME_DEBUG

#define BUILTIN_LED 2 

/* by enable that we enforrce the connection to be closed after each transmission */
//#define RECON

#define CRY_DEBUG
#define CRY_DEBUG_AES
//#define CRY_DEBUG_RSA_SIGN
#define BLOCK_SIZE 16

/*size of the message */
#define Size_Byte 5120

/*size of the encrypted key */
#define C_SIZE 128


//#define OSLOENABLE
 uint8_t * mymsg; 

/* symmetric key to encrypt the data */
uint8_t key[BLOCK_SIZE] = {0x1C, 0x3E ,0x4B, 0xAF, 0x13, 0x4A, 0x89, 0xC3, 0xF3, 0x87, 0x4F, 0xBC, 0xD7, 0xF3, 0x31, 0x31};

/*
 * Key Store Public key 
 */
const unsigned char  ks_pk_key[] = \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRkq1PtnLdEuOXT6u48WkQJv+x\n" \
"agZt8nlasKbSfyq+HwOBUkiII5dX4dpCCaAaOLPpeaQ506EOILPrkeLNEvpRBhf8\n" \
"z3f7156obdd7P92UkrsiinEHbRWHoWcdHYNTaQhC5YUKMmvZgOVDu9YHsrtpFfFj\n" \
"JBYQH5bq0t+M6uQNBQIDAQAB\n" \
"-----END PUBLIC KEY-----\n";

/*
 * IOT RSA public and prrivate keys generated by openssl 
 */

/* public key 1024 bit */
const unsigned char iot_pk_key[]= \
"-----BEGIN PUBLIC KEY-----\n" \
"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDlIE7AG22mns40Zv6XIsKie61w\n" \
"xZy6NmAON1mFU3bgYy5lEA3X0VHRJtsAwnMTGNzBc/hw8VL/2xARn7Xh7oOCLm+I\n" \
"eCqDnfJUE9u7u1ayZfUNojoNbj7B8AT2j3O/LPsna67l97zspD11DTe/cpL8IKlj\n" \
"acXs2HjxLGXtX2Tv8wIDAQAB\n" \
"-----END PUBLIC KEY-----\n";

const unsigned char iot_pr_key[]= \
"-----BEGIN RSA PRIVATE KEY-----\n" \
"MIICXgIBAAKBgQDlIE7AG22mns40Zv6XIsKie61wxZy6NmAON1mFU3bgYy5lEA3X\n" \
"0VHRJtsAwnMTGNzBc/hw8VL/2xARn7Xh7oOCLm+IeCqDnfJUE9u7u1ayZfUNojoN\n" \
"bj7B8AT2j3O/LPsna67l97zspD11DTe/cpL8IKljacXs2HjxLGXtX2Tv8wIDAQAB\n" \
"AoGBAKJv+ySazWv43fusoQWI8S+8OsPedTRW5FZvyxmIiJif9/5SGV5N2ZFL2Kt7\n" \
"L5X0ZF0J2LJJhCw7o/K6pXmdXMEQkrKoTwhObwWfbHXmb6KDBQJ2cFoV1BwO/K6O\n" \
"xQtPOC4C4Qg0GeVxkK3U1Isr8CKuK9w4huuSUbCZIVkBrWYxAkEA+gXgpTaTwVvQ\n" \
"NrBRRvY/HQooSm0oJvgQWvAoWMS7Psrq80nyrFq+L80SMbFrNizUVqJkDTJ5vCrR\n" \
"2zFHl/UBfwJBAOqaix9/cZbWKjc7zlJcgAJRDUgXvSpeyJMVJk7+1L4LwQg6v++n\n" \
"jahRwSrU9HuLy6a6YtAUK8A0wsTNn4OhY40CQEiTjDJpNVrbnAVECVPgB1IWsLtq\n" \
"FE27lIPRUuTxtqjznmAhByCg9rRJgw6JweVn/ftoCEMMc+n7RA+srmud42ECQQCT\n" \
"jkhas0m6WVGME+2dF9jbnCcCZQvxjlQRTogdv2IHdlUe2/TEw1nxuBoK2o469p5M\n" \
"a4ai4UzzQzwNlFbz75oxAkEAgu4TyqG8mr0vAlA3RWVtd41tulzNTN0N85ia5SnV\n" \
"17399lTOp6j/qyMlhQVZZKP9T7ndYCqJdjHPNStOpuAWiA==\n" \
"-----END RSA PRIVATE KEY-----\n";

// Update these with values suitable for your network.
const char* ssid = "Commodore64";
const char* password = "ma0s#verSuch";
const char* mqtt_server =  "192.168.178.37"; //"mqtt.eclipse.org";
const int mqttPort = 1883; 

const char * topic = "mhh_my_topic";
const char * k_topic = "mhh_sec_key";

WiFiClient espClient;
PubSubClient mqttclient(espClient);

unsigned long lastMsg = 0;
#define MSG_BUFFER_SIZE  (50)
char msg[MSG_BUFFER_SIZE];
int value = 0; /* counter for the messages*/

/*
 *  function for RSA encryption and signing operation 
 */

/*
 * call plattform-specific  TRNG driver
 */
static int myrand(void *rng_state, unsigned char *output, size_t len)
{
    size_t olen;
    return mbedtls_hardware_poll(rng_state, output, len, &olen);
}

/*
 * RSA SIGNING
 * input: message to be signed 
 * P_SIZE: the message size
 * sign: the output signature (size = 128)
 */

void rsa_sign(unsigned char * input, size_t P_SIZE, unsigned char * sign)
{
    mbedtls_pk_context  pr; 
    mbedtls_pk_init(&pr);
    int error_code_pr ; 
    #ifdef DBG_PRINT 
      Serial.println("Input Text");
      dbgPrint(input, 0 ,P_SIZE);
    #endif
    error_code_pr =  mbedtls_pk_parse_key(&pr, iot_pr_key, sizeof(iot_pr_key), NULL, NULL);
    if(error_code_pr != 0)
    {
       #ifdef DBG_PRINT 
       Serial.println( "READING PRIVATE KEY NOT SUCCESSFULL");
       #endif
       mbedtls_pk_free(&pr); 
       return ;
    }
    else
    {
       #ifdef DBG_PRINT 
       Serial.println( "READING PRIVATE KEY SUCCESSFULL");
       #endif

       /* compute the SHA-256 hash for the input*/
       unsigned char hash[32]; 
       int hash_ret; 
       hash_ret = mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), input, P_SIZE, hash); 
       if( hash_ret != 0 )
       {
            #ifdef DBG_PRINT 
             Serial.println( "Calculating HASH not SUCCESSFULL");
            #endif
            mbedtls_pk_free(&pr);
            return ; 
        }
        else
        {
          #ifdef DBG_PRINT 
            Serial.println( " Calculating HASH SUCCESSFULL");
            Serial.println( " Hash :"); 
            dbgPrint(hash, 0 , sizeof(hash)); 
          #endif
          int sign_ret;
          size_t olen = 0; 
          sign_ret = mbedtls_pk_sign(&pr, MBEDTLS_MD_SHA256, hash, 0, sign, &olen, myrand, NULL);
          if (sign_ret != 0)
          {
            #ifdef DBG_PRINT 
             Serial.println( " Sign not SUCCESSFULL");
            #endif
            mbedtls_pk_free(&pr);
            return;
          }
          else 
          {
            #ifdef DBG_PRINT 
             Serial.println( " Sign  SUCCESSFULL");
             Serial.println( " Sign :"); 
             dbgPrint(sign, 0 ,olen );
            #endif
           }
        }
  }
  mbedtls_pk_free(&pr); 
}


/*
 * RSA Encryption 
 */
size_t rsa_encryption(unsigned char * plainText, size_t P_SIZE, unsigned char * cipher)
{
  int error_code; 
  mbedtls_pk_context pk; 
  mbedtls_pk_init(&pk);
  error_code =  mbedtls_pk_parse_public_key(&pk, ks_pk_key, sizeof(ks_pk_key));
  
  if( error_code!= 0)
  {
    #ifdef DBG_PRINT  
      Serial.println( "READING KEY STORE PUBLIC KEY NOT SUCCESSFULL");
    #endif
    mbedtls_pk_free(&pk);
    return  -1;  
  }
  else
  {
    #ifdef DBG_PRINT  
      Serial.println("READING KEY STORE PUBLIC KEY SUCCESSFULL");
      Serial.println(sizeof(plainText)); 
      Serial.println("Plain Text"); 
      dbgPrint(plainText, 0 , P_SIZE); 
    #endif
    size_t oolen;
    int result = mbedtls_pk_encrypt( &pk, plainText, P_SIZE, cipher, &oolen, C_SIZE, myrand, NULL );
    if (result == 0)
    {
      #ifdef DBG_PRINT 
        Serial.println( "Encryption SUCCESSFULL");
        Serial.println("Encrypted Text");
        dbgPrint(cipher, 0 ,oolen);
      #endif
      mbedtls_pk_free(&pk);
      return oolen;
    } 
    else
    {
      #ifdef DBG_PRINT 
        Serial.println( "Encryption NOT SUCCESSFULL");
      #endif
      mbedtls_pk_free(&pk);
      return -1;
    }
  }
}

/* 
 *  adjust the length of the ciphered text
 */
void bufferSize(char* text, int &length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  // length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
  length = (buf <= i) ? buf + BLOCK_SIZE : buf;
}

void uninttochar(uint8_t* input, int lenght, char* output)
{
  Serial.println(" line is "); 
  Serial.println(lenght); 
  char* k = output; 
  for (int i = 0; i < lenght; i++) 
  { 
     Serial.print(i); 
     Serial.print(" >> ");
     Serial.println(input[i], HEX); 
     sprintf(k, "%02X", (uint8_t)input[i]); 
     k += 2;
  }
  k[lenght]= '\0';
}

/*
 * Encrypt message pt (plain text) using the defined key and store the encrypted inplace
 */
void aes_encryption(uint8_t * input, uint8_t * output) {
  mbedtls_aes_context aes;
  uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  
  #ifdef DBG_PRINT 
    Serial.println("<<<<<<<<<<<<<<< Start Encryption >>>>>>>>>>>>>>>>>");
    Serial.println("Plain Text:");
    dbgPrint(input,Size_Byte -32, Size_Byte);
  #endif

  mbedtls_aes_init( &aes );
  mbedtls_aes_setkey_enc( &aes, (const unsigned char*) key, BLOCK_SIZE * 8);
  mbedtls_aes_crypt_cbc(&aes, MBEDTLS_AES_ENCRYPT, Size_Byte, iv, input, output);
  #ifdef DBG_PRINT 
    Serial.println(" Encryptted text:");
    dbgPrint(output, Size_Byte -32, Size_Byte);
    Serial.println("<<<<<<<<<<<<<<<< End Encryption >>>>>>>>>>>>>>>>>>");
  #endif
  mbedtls_aes_free( &aes );
}
 
static uint8_t  *rand_string(uint8_t  *str, size_t size) {
  const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
  if (size) {
    --size;
    for (size_t n = 0; n < size; n++) {
      int key = rand() % 16;
      str[n] = key;
    }
  }
  return str;
}

uint8_t* rand_string_alloc(size_t size) {
  uint8_t* s =(uint8_t  *) malloc(size);
  if (s) {
    rand_string(s, size);
  }
  return s;
}

void loop() {
  //Serial.println("START"); 
  if (!mqttclient.connected()) {
    reconnect();
  }
  
  unsigned long now = millis();
  if (now - lastMsg > 5000) {
    unsigned long t_b = micros();
    lastMsg = now;
    ++value;
  
    Datatransmission(value);
    KSdate(value);
    
    unsigned long t_e = micros();

    Serial.print("Time for whole process:"); 
    Serial.print(t_e - t_b);
    Serial.println(" (us)");  
    #ifdef RECON
      mqttclient.disconnect();
    #endif
  }
  mqttclient.loop();
}

void setup_wifi() {
  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  unsigned long b_conap= micros();

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  unsigned long e_conap= micros();
  Serial.print(" Time to connect to AP is :" );
  Serial.print(e_conap - b_conap);
  Serial.println(" (us)"); 
  randomSeed(micros());

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}


void reconnect() {
  // Loop until we're reconnected
  while (!mqttclient.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Create a random client ID
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    #ifdef OSLOENABLE
      digitalWrite(13, HIGH);
    #endif
    unsigned long b_conn = micros();
    if (mqttclient.connect(clientId.c_str())) {
      unsigned long e_conn = micros();
      #ifdef OSLOENABLE
        digitalWrite(13, LOW);
      #endif
      Serial.println("connected");
      digitalWrite(BUILTIN_LED, HIGH);
      #ifdef TIME_DEBUG
        Serial.print("Time to estiblsh connection with server is:");
        Serial.print(e_conn - b_conn);
        Serial.println(" (us)"); 
      #endif
    } else {
      Serial.print("failed, rc=");
      Serial.print(mqttclient.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}

void KSdate(int value) {
  size_t cred_len ; /* credential length*/
  size_t sig_len = 128 ;  /*signature length*/
  unsigned char signnature[sig_len]; 
  size_t c_len = 128;  /* length of the encrypted key*/
  unsigned char cipher[c_len] ={0};
  size_t len ; 
  size_t m_len; /* the total lenght of the credential, signature and the encrypted key*/
     
  unsigned char cred[]= \
      "KeyNote-Version: 2\n" \
      "Authorizer: \"RSA:dab212\" \n" \     
      "Licensees: \"DSA:feed1234\" \n" \
      "Conditions: (app_domain==\"KS\")-> { (Process) < 2500) -> _MAX_TRUST; Signature: ";
  cred_len = strlen((char *)cred);

  /*signing the credential*/ 
  unsigned long b_crsign = micros();
  rsa_sign(cred, cred_len, signnature);
  unsigned long e_crsign = micros();
  #ifdef TIME_DEBUG
    Serial.print("Time to sign the credential: ");
    Serial.print(e_crsign - b_crsign);
    Serial.println(" (us) "); 
  #endif
   
  /* encrypting the session key */
  unsigned long b_keyenc = micros();
  len = rsa_encryption(key, BLOCK_SIZE, cipher); /* we need to check the length here*/
  unsigned long e_keyenc = micros();

  #ifdef TIME_DEBUG
    Serial.print("Time to encrypt the key :");
    Serial.print(e_keyenc - b_keyenc);
    Serial.println(" (us) "); 
  #endif
   
  m_len = len +  sig_len + cred_len ; 
  /*
  ----------------------------------------
  | Encrypted Key | Signature | credential |
  ----------------------------------------
  */
  unsigned char message[m_len]={}; 
  memcpy((unsigned char *)message, (unsigned char *)cipher, len); 
  memcpy((unsigned char *)message + len, (unsigned char *)signnature, sig_len);
  memcpy((unsigned char *)message + len+ sig_len, (unsigned char *)cred, cred_len);
   
  #ifdef OSLOENABLE
    digitalWrite(13, HIGH);
  #endif
  
  unsigned long b_kmsend = micros();
  mqttclient.beginPublish(k_topic, m_len, true);
  mqttclient.write((byte *)message, m_len); 
  mqttclient.endPublish();
  unsigned long e_kmsend = micros();
    
  #ifdef OSLOENABLE
    digitalWrite(13, LOW);
  #endif

  #ifdef TIME_DEBUG
    char timemsg[50] ; 
    snprintf(timemsg, MSG_BUFFER_SIZE, "Time to send the %d key :", value);
    Serial.print(timemsg); 
    Serial.print(e_kmsend - b_kmsend);
    Serial.println(" (us) "); 
  #endif
}

void Datatransmission(int value) {
  //int length = 0; 
  //bufferSize(mymsg, length);

  unsigned char output[Size_Byte] = {}; 
  aes_encryption(mymsg, output);
   
  #ifdef OSLOENABLE
    digitalWrite(13, HIGH);
  #endif
  unsigned long b_msgsend = micros();
  mqttclient.beginPublish(topic, Size_Byte, true); 
  mqttclient.write((byte *)output, (int)Size_Byte); 
  mqttclient.endPublish ();
  unsigned long e_msgsend = micros();
  #ifdef OSLOENABLE
    digitalWrite(13, LOW);
  #endif
    
  #ifdef TIME_DEBUG
    char timemsg [50] ; 
    snprintf (timemsg, MSG_BUFFER_SIZE, "Time to send %ld Bytes :", Size_Byte );
    Serial.print(timemsg); 
    Serial.print(e_msgsend - b_msgsend);
    Serial.println(" (us) "); 
  #endif
}
 
 
/*
 * Print array
 * size: the size of the array 
 * beg: index to start printing 
 */
void dbgPrint(uint8_t * arr, int beg ,int size) {
  Serial.println();
  int start = beg; //defualt = 0
  int row = 0 ;
  Serial.print(row); 
  Serial.print(" >> ");  
  for (int i = start; i < size; i++)
  {
     if(i > 0 && i % BLOCK_SIZE == 0)
     {
      row++;
      Serial.println(); 
      Serial.print(row); 
      Serial.print(" >> ");
     }
    Serial.print(arr[i], HEX); 
    Serial.print(" "); 
  }
  Serial.println();
}


void setup() {
  //pinMode(BUILTIN_LED, OUTPUT);     // Initialize the BUILTIN_LED pin as an output
  pinMode(13, OUTPUT);
  Serial.begin(115200);

  setup_wifi();
  mymsg = rand_string_alloc(Size_Byte);
  mqttclient.setServer(mqtt_server, mqttPort);
}
